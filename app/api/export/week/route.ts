import { NextRequest } from 'next/server';
import { q } from '@/lib/db';
import { ceil15 } from '@/lib/rounding';
import { format } from 'date-fns';
function toCsv(rows:any[]){ const headers=Object.keys(rows[0]||{}); const lines=[headers.join(',')]; for(const r of rows) lines.push(headers.map(h=>JSON.stringify(r[h]??'')).join(',')); return lines.join('\n'); }
export async function GET(req: NextRequest){ const url=new URL(req.url); const weekStart=url.searchParams.get('start'); if(!weekStart) return new Response('missing start',{status:400}); const {rows}=await q(`with seg as ( select employee_id, customer_id, function_id, date_trunc('day', started_at)::date as day, sum(extract(epoch from coalesce(ended_at, now()) - started_at)/60) filter (where is_break = false) as work_min, sum(extract(epoch from coalesce(ended_at, now()) - started_at)/60) filter (where is_break = true) as break_min from time_segments where started_at >= $1::date and started_at < ($1::date + interval '7 day') group by 1,2,3,4 ) select e.full_name as employee, c.name as customer, f.name as function, day, greatest(0, coalesce(work_min,0) - coalesce(break_min,0)) as minutes_raw from seg join employees e on e.id = seg.employee_id join customers c on c.id = seg.customer_id join functions f on f.id = seg.function_id order by employee, day, customer, function;`,[weekStart]); const mapped=rows.map((r:any)=>{ const minutes=Number(r.minutes_raw||0); const rounded=ceil15(minutes); return { Date: format(new Date(r.day),'yyyy-MM-dd'), Employee: r.employee, Customer: r.customer, Function: r.function, Minutes: Math.round(minutes), MinutesRounded: rounded, HoursRounded: (rounded/60).toFixed(2)}; }); const csv=toCsv(mapped); return new Response(csv,{headers:{'Content-Type':'text/csv','Content-Disposition':`attachment; filename="time_${weekStart}.csv"`}}); }
